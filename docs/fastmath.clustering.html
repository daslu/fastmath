<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>fastmath.clustering documentation</title><script type="text/javascript" async="" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML"></script><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="highlight/solarized-light.css" /><script type="text/javascript" src="highlight/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a> with <a href="https://github.com/xsc/codox-theme-rdash">RDash UI</a> theme</h2><h1><a href="index.html"><span class="project-title"><span class="project-name">Fastmath</span> <span class="project-version">2.1.5</span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1"><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>fastmath</span></div></div></li><li class="depth-2 branch current"><a href="fastmath.clustering.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>clustering</span></div></a></li><li class="depth-2 branch"><a href="fastmath.complex.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>complex</span></div></a></li><li class="depth-2 branch"><a href="fastmath.core.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>core</span></div></a></li><li class="depth-2 branch"><a href="fastmath.distance.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>distance</span></div></a></li><li class="depth-2 branch"><a href="fastmath.easings.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>easings</span></div></a></li><li class="depth-2 branch"><a href="fastmath.fields.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>fields</span></div></a></li><li class="depth-2 branch"><a href="fastmath.gp.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>gp</span></div></a></li><li class="depth-2 branch"><a href="fastmath.grid.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>grid</span></div></a></li><li class="depth-2 branch"><a href="fastmath.interpolation.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>interpolation</span></div></a></li><li class="depth-2 branch"><a href="fastmath.kernel.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>kernel</span></div></a></li><li class="depth-2"><a href="fastmath.optimization.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>optimization</span></div></a></li><li class="depth-3"><a href="fastmath.optimization.bo.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>bo</span></div></a></li><li class="depth-2 branch"><a href="fastmath.protocols.html"><div class="inner"><span class="tree" style="top: -52px;"><span class="top" style="height: 61px;"></span><span class="bottom"></span></span><span>protocols</span></div></a></li><li class="depth-2 branch"><a href="fastmath.random.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>random</span></div></a></li><li class="depth-2 branch"><a href="fastmath.signal.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>signal</span></div></a></li><li class="depth-2 branch"><a href="fastmath.stats.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>stats</span></div></a></li><li class="depth-2 branch"><a href="fastmath.transform.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>transform</span></div></a></li><li class="depth-2"><a href="fastmath.vector.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>vector</span></div></a></li></ul></div><div class="sidebar secondary"><h3><a href="#top"><span class="inner">Public Vars</span></a></h3><ul><li class="depth-1"><a href="fastmath.clustering.html#var-clarans"><div class="inner"><span>clarans</span></div></a></li><li class="depth-1"><a href="fastmath.clustering.html#var-clustering-methods-list"><div class="inner"><span>clustering-methods-list</span></div></a></li><li class="depth-1"><a href="fastmath.clustering.html#var-dbscan"><div class="inner"><span>dbscan</span></div></a></li><li class="depth-1"><a href="fastmath.clustering.html#var-denclue"><div class="inner"><span>denclue</span></div></a></li><li class="depth-1"><a href="fastmath.clustering.html#var-deterministic-annealing"><div class="inner"><span>deterministic-annealing</span></div></a></li><li class="depth-1"><a href="fastmath.clustering.html#var-g-means"><div class="inner"><span>g-means</span></div></a></li><li class="depth-1"><a href="fastmath.clustering.html#var-k-means"><div class="inner"><span>k-means</span></div></a></li><li class="depth-1"><a href="fastmath.clustering.html#var-lloyd"><div class="inner"><span>lloyd</span></div></a></li><li class="depth-1"><a href="fastmath.clustering.html#var-mec"><div class="inner"><span>mec</span></div></a></li><li class="depth-1"><a href="fastmath.clustering.html#var-outlier-id"><div class="inner"><span>outlier-id</span></div></a></li><li class="depth-1"><a href="fastmath.clustering.html#var-predict"><div class="inner"><span>predict</span></div></a></li><li class="depth-1"><a href="fastmath.clustering.html#var-regroup"><div class="inner"><span>regroup</span></div></a></li><li class="depth-1"><a href="fastmath.clustering.html#var-spectral"><div class="inner"><span>spectral</span></div></a></li><li class="depth-1"><a href="fastmath.clustering.html#var-x-means"><div class="inner"><span>x-means</span></div></a></li></ul></div><div class="namespace-docs" id="content"><h1 class="anchor" id="top">fastmath.clustering</h1><div class="doc"><div class="markdown"><p>Clustering.</p>
<p>Various clustering algrorithms backed by SMILE library.</p>
<p>Only partition clustering is implemented.</p>
<h3><a href="#input-data" name="input-data"></a>Input data</h3>
<p>Itâ€™s always sequence of n-sized samples as sequences.</p>
<p>For example, 2d samples <code>[[1 2] [2 2] [3 3] ...]</code></p>
<p>For 1d data you can pass sequence of numbers of sequence of 1d seqs of numbers</p>
<pre><code class="clojure">[1 2 3]
;; or
[[1] [2] [3]]
</code></pre>
<h3><a href="#distances" name="distances"></a>Distances</h3>
<p>Some of the methods use distance functions, use <a href="fastmath.distance.html">fastmath.distance</a> namespace to create one.</p>
<h3><a href="#output" name="output"></a>Output</h3>
<p>Every function returns record which contains:</p>
<ul>
  <li><code>:type</code> - name of the method used</li>
  <li><code>:data</code> - input data</li>
  <li><code>:clustering</code> - sequence of cluster ids</li>
  <li><code>:sizes</code> - sizes of clusters</li>
  <li><code>:clusters</code> - number of clusters</li>
  <li><code>:predict</code> - predicting function (see below), qualify additional sample</li>
  <li><code>:representatives</code> - list of centroids or averages</li>
  <li><code>:info</code> - additional statistics for your samples (like distortion)</li>
  <li><code>:obj</code> - SMILE object</li>
</ul>
<p>Cluster id is a integer ranging from 0 to the number of clusters minus 1. Some methods mark outliers with <a href="fastmath.clustering.html#var-outlier-id">outlier-id</a>.</p>
<p>Record acts as function and can qualify additonal sample by calling <code>:predict</code> function (or just call <a href="fastmath.clustering.html#var-predict">predict</a>), for example (<code>data</code> is sequence of 3d samples):</p>
<pre><code class="clojure">(let [cl (k-means data 10)] (cl [0 1 2]))
</code></pre>
<p>See <a href="fastmath.clustering.html#var-k-means">k-means</a></p>
<h4><a href="#regrouping" name="regrouping"></a>Regrouping</h4>
<p>Clustering record can be regroupped to the list of individual clusters. Call <a href="fastmath.clustering.html#var-regroup">regroup</a> and get list of maps with following structure:</p>
<ul>
  <li><code>:key</code> - cluster id or <code>:outliers</code></li>
  <li><code>:data</code> - samples which belong to the cluster</li>
  <li><code>:representative</code> - centroid or average vector if the former is not available</li>
  <li><code>:size</code> - size of cluster</li>
</ul></div><div class="markdown"><h4>Categories</h4><ul></ul><p>Other vars: <a>-&gt;ClusteringResult</a> <a href="fastmath.clustering.html#var-clarans">clarans</a> <a href="fastmath.clustering.html#var-clustering-methods-list">clustering-methods-list</a> <a href="fastmath.clustering.html#var-dbscan">dbscan</a> <a href="fastmath.clustering.html#var-denclue">denclue</a> <a href="fastmath.clustering.html#var-deterministic-annealing">deterministic-annealing</a> <a href="fastmath.clustering.html#var-g-means">g-means</a> <a href="fastmath.clustering.html#var-k-means">k-means</a> <a href="fastmath.clustering.html#var-lloyd">lloyd</a> <a>map-&gt;ClusteringResult</a> <a href="fastmath.clustering.html#var-mec">mec</a> <a href="fastmath.clustering.html#var-predict">predict</a> <a href="fastmath.clustering.html#var-regroup">regroup</a> <a href="fastmath.clustering.html#var-spectral">spectral</a> <a href="fastmath.clustering.html#var-x-means">x-means</a></p></div><div class="markdown"><h4>Constants</h4><ul><li><a href="fastmath.clustering.html#var-outlier-id">outlier-id</a> = <code>2147483647</code></li></ul></div></div><div class="public anchor" id="var-clarans"><h3>clarans</h3><div class="usage"><code>(clarans data clusters)</code><code>(clarans data dist clusters)</code><code>(clarans data dist clusters max-neighbor)</code></div><div class="doc"><div class="markdown"><p>Clustering Large Applications based upon RANdomized Search algorithm.</p>
<p>Input:</p>
<ul>
  <li>data - sequence of samples</li>
  <li>dist (optional) - distance method, default <code>euclidean</code></li>
  <li>clusters - number of clusters</li>
  <li>max-neighbor (optional) - maximum number of neighbors checked during random search</li>
</ul>
<p>See more in <a href="https://haifengl.github.io/api/java/smile/clustering/CLARANS.html">SMILE doc</a></p></div></div><div class="markdown"><h4>Examples</h4><div><blockquote><p>Usage</p></blockquote><pre><code class="hljs clojure">(dissoc (clarans (repeatedly
                  1000
                  (fn* []
                    (r/randval 0.1 (r/irand -10 10) (r/irand 100 150))))
                 d/chebyshev
                 2)
        :data :clustering
        :obj :predict)
;;=&gt; {:clusters 2,
;;=&gt;  :info {:distortion 11898.0},
;;=&gt;  :representatives ((123.0) (-1.0)),
;;=&gt;  :sizes (903 97 0),
;;=&gt;  :type :clarans}</code></pre></div></div><div class="src-link"><a href="https://github.com/generateme/fastmath/blob/master/src/fastmath/clustering.clj#L234">view source</a></div></div><div class="public anchor" id="var-clustering-methods-list"><h3>clustering-methods-list</h3><div class="usage"></div><div class="doc"><div class="markdown"><p>List of clustering methods.</p></div></div><div class="markdown"><h4>Examples</h4><div><blockquote><p>List of methods</p></blockquote><pre><code class="hljs clojure">clustering-methods-list
;;=&gt; (:spectral :dbscan
;;=&gt;            :k-means :mec
;;=&gt;            :clarans :g-means
;;=&gt;            :lloyd :x-means
;;=&gt;            :deterministic-annealing :denclue)</code></pre></div></div><div class="src-link"><a href="https://github.com/generateme/fastmath/blob/master/src/fastmath/clustering.clj#L139">view source</a></div></div><div class="public anchor" id="var-dbscan"><h3>dbscan</h3><div class="usage"><code>(dbscan data min-pts radius)</code><code>(dbscan data dist min-pts radius)</code></div><div class="doc"><div class="markdown"><p>Density-Based Spatial Clustering of Applications with Noise algorithm.</p>
<p>Input:</p>
<ul>
  <li>data - sequence of samples</li>
  <li>dist (optional) - distance method, default <code>euclidean</code></li>
  <li>min-pts - minimum number of neighbors</li>
  <li>radius - the neighborhood radius</li>
</ul>
<p>See more in <a href="https://haifengl.github.io/api/java/smile/clustering/DBSCAN.html">SMILE doc</a></p></div></div><div class="markdown"><h4>Examples</h4><div><blockquote><p>3d vectors</p></blockquote><pre><code class="hljs clojure">(dissoc (dbscan
         (repeatedly
          5000
          (fn* []
            (vector (r/randval 0.1 (r/irand -10 10) (r/irand 100 150))
                    (r/randval (r/irand -10 10) (r/irand 100 150))
                    (r/randval (r/irand -10 10) (r/irand 100 150)))))
         10
         20)
        :data :clustering
        :obj :predict)
;;=&gt; {:clusters 8,
;;=&gt;  :info {},
;;=&gt;  :representatives nil,
;;=&gt;  :sizes (1116 1164 1119 1101 125 132 117 126 0),
;;=&gt;  :type :dbscan}</code></pre></div></div><div class="src-link"><a href="https://github.com/generateme/fastmath/blob/master/src/fastmath/clustering.clj#L265">view source</a></div></div><div class="public anchor" id="var-denclue"><h3>denclue</h3><div class="usage"><code>(denclue data sigma m)</code><code>(denclue data sigma m tolerance)</code><code>(denclue data sigma m tolerance min-pts)</code></div><div class="doc"><div class="markdown"><p>DENsity CLUstering algorithm.</p>
<p>Input:</p>
<ul>
  <li>data - sequence of samples</li>
  <li>sigma - gaussian kernel parameter</li>
  <li>m - number of selected samples, much smaller than number of all samples</li>
  <li>tolerance (optional) - tolerance of hill-climbing procedure</li>
  <li>min-pts (optional) - minimum number of neighbors for a core attractor</li>
</ul>
<p>See more in <a href="https://haifengl.github.io/api/java/smile/clustering/DENCLUE.html">SMILE doc</a></p></div></div><div class="markdown"><h4>Examples</h4><div><blockquote><p>Expect 2 clusters, uniform distribution.</p></blockquote><pre><code class="hljs clojure">((juxt :clusters :sizes :representatives)
 (denclue (repeatedly 100 (fn* [] (r/randval (r/drand) (r/drand 5 6))))
          1
          10))
;;=&gt; [2 (49 51 0) nil]
(map
 (fn [m] (dissoc m :data))
 (regroup
  (denclue (repeatedly 1000
                       (fn* [] (r/randval 0.1 (r/drand) (r/drand 5 6))))
           1
           10)))
;;=&gt; ({:key 0, :representative 5.506357745762178, :size 895}
;;=&gt;  {:key 1, :representative 0.5458396084599264, :size 105})</code></pre></div></div><div class="src-link"><a href="https://github.com/generateme/fastmath/blob/master/src/fastmath/clustering.clj#L249">view source</a></div></div><div class="public anchor" id="var-deterministic-annealing"><h3>deterministic-annealing</h3><div class="usage"><code>(deterministic-annealing data max-clusters)</code><code>(deterministic-annealing data max-clusters alpha)</code><code>(deterministic-annealing data max-clusters alpha max-iter)</code><code>(deterministic-annealing data max-clusters alpha max-iter tolerance)</code><code>(deterministic-annealing data max-clusters alpha max-iter tolerance split-tolerance)</code></div><div class="doc"><div class="markdown"><p>Deterministic Annealing algorithm.</p>
<p>Input:</p>
<ul>
  <li>data - sequence of samples</li>
  <li>max-clusters - number of clusters</li>
  <li>alpha (optional) - temperature decreasing factor (valued from 0 to 1)</li>
  <li>max-iter (optional) - maximum number of iterations</li>
  <li>tolerance (optional) - tolerance of convergence test</li>
  <li>split-tolerance (optional) - tolerance to split a cluster</li>
</ul>
<p>See more in <a href="https://haifengl.github.io/api/java/smile/clustering/DeterministicAnnealing.html">SMILE doc</a></p></div></div><div class="markdown"><h4>Examples</h4><div><blockquote><p>Usage</p></blockquote><pre><code class="hljs clojure">(map (fn [m] (dissoc m :data))
     (-&gt; (repeatedly 1000
                     (fn* []
                       (vector (r/randval (r/grand) (r/grand 5 1.0))
                               (r/randval (r/grand) (r/grand 5 1.0)))))
         (deterministic-annealing 4 0.5)
         (regroup)))
;;=&gt; ({:key 1,
;;=&gt;   :representative (0.0715631120012915 4.944263843953285),
;;=&gt;   :size 248}
;;=&gt;  {:key 3,
;;=&gt;   :representative (4.981940213922107 4.986080751366004),
;;=&gt;   :size 261}
;;=&gt;  {:key 2,
;;=&gt;   :representative (5.012104305437034 0.10620674492016231),
;;=&gt;   :size 246}
;;=&gt;  {:key 0,
;;=&gt;   :representative (0.064841476760864 -0.09055930383753957),
;;=&gt;   :size 245})</code></pre></div></div><div class="src-link"><a href="https://github.com/generateme/fastmath/blob/master/src/fastmath/clustering.clj#L212">view source</a></div></div><div class="public anchor" id="var-g-means"><h3>g-means</h3><div class="usage"><code>(g-means data clusters)</code><code>(g-means data clusters max-iter)</code><code>(g-means data clusters max-iter tolerance)</code></div><div class="doc"><div class="markdown"><p>G-Means</p>
<p>Input:</p>
<ul>
  <li>data - sequence of samples</li>
  <li>clusters - number of clusters</li>
  <li>max-iter (optional) - maximum number of iterations</li>
  <li>tolerance (optional) - tolerance of convergence test</li>
</ul>
<p>See more in <a href="https://haifengl.github.io/api/java/smile/clustering/GMeans.html">SMILE doc</a></p></div></div><div class="markdown"><h4>Examples</h4><div><blockquote><p>Expect 2 clusters, uniform distribution.</p></blockquote><pre><code class="hljs clojure">((juxt :clusters :sizes :representatives)
 (g-means (repeatedly 100 (fn* [] (r/randval (r/drand) (r/drand 5 6))))
          4))
;;=&gt; [2 (45 55 0) ((5.454851407098227) (0.44278422207772483))]</code></pre></div></div><div class="src-link"><a href="https://github.com/generateme/fastmath/blob/master/src/fastmath/clustering.clj#L182">view source</a></div></div><div class="public anchor" id="var-k-means"><h3>k-means</h3><div class="usage"><code>(k-means data clusters)</code><code>(k-means data clusters max-iter)</code><code>(k-means data clusters max-iter tolerance)</code></div><div class="doc"><div class="markdown"><p>K-Means++ algorithm.</p>
<p>Input:</p>
<ul>
  <li>data - sequence of samples</li>
  <li>clusters - number of clusters</li>
  <li>max-iter (optional) - maximum number of iterations</li>
  <li>tolerance (optional) - tolerance of convergence test</li>
</ul>
<p>See more in <a href="https://haifengl.github.io/api/java/smile/clustering/KMeans.html">SMILE doc</a></p></div></div><div class="markdown"><h4>Examples</h4><div><blockquote><p>Usage</p></blockquote><pre><code class="hljs clojure">(k-means [1 2 3 -1 -1 2 -1 11 111] 4)
;;=&gt; #fastmath.clustering.ClusteringResult
;;=&gt;  {:clustering (3 3 3 0 0 3 0 2 1),
;;=&gt;   :clusters 4,
;;=&gt;   :data [1 2 3 -1 -1 2 -1 11 111],
;;=&gt;   :info {:distortion 2.0000000000000004},
;;=&gt;   :obj
;;=&gt;   #object[smile.clustering.KMeans 0x183b884f "Cluster distortion: 2.00000\nCluster size of 9 data points:\nCluster    1      3 (33.3%)\nCluster    2      1 (11.1%)\nCluster    3      1 (11.1%)\nCluster    4      4 (44.4%)\n"],
;;=&gt;   :predict #<fn@b2dc176 fastmath.clustering="" _means[fn]="">,
;;=&gt;   :representatives ((-1.0) (111.0) (11.0) (2.0)),
;;=&gt;   :sizes (3 1 1 4 0),
;;=&gt;   :type :k-means}</fn@b2dc176></code></pre></div><div><blockquote><p>Clusters group into separate maps.</p></blockquote><pre><code class="hljs clojure">(regroup (k-means [1 2 3 -1 -1 2 -1 11 111] 4))
;;=&gt; ({:data (1 2 3 2), :key 3, :representative (2.0), :size 4}
;;=&gt;  {:data (-1 -1 -1), :key 0, :representative (-1.0), :size 3}
;;=&gt;  {:data (11), :key 2, :representative (11.0), :size 1}
;;=&gt;  {:data (111), :key 1, :representative (111.0), :size 1})</code></pre></div><div><blockquote><p>Use as predictor</p></blockquote><pre><code class="hljs clojure">(let [cl (k-means [1 2 3 -1 -1 2 -1 11 111] 4)]
  [(cl -1) (cl 10) (cl 100) (cl 1) (cl -1000) (cl 1000)])
;;=&gt; [3 2 1 0 3 1]</code></pre></div></div><div class="src-link"><a href="https://github.com/generateme/fastmath/blob/master/src/fastmath/clustering.clj#L152">view source</a></div></div><div class="public anchor" id="var-lloyd"><h3>lloyd</h3><div class="usage"><code>(lloyd data clusters)</code><code>(lloyd data clusters max-iter)</code><code>(lloyd data clusters max-iter tolerance)</code></div><div class="doc"><div class="markdown"><p>K-Means algorithm, lloyd.</p>
<p>Input:</p>
<ul>
  <li>data - sequence of samples</li>
  <li>clusters - number of clusters</li>
  <li>max-iter (optional) - maximum number of iterations</li>
  <li>tolerance (optional) - tolerance of convergence test</li>
</ul>
<p>See more in <a href="https://haifengl.github.io/api/java/smile/clustering/KMeans.html">SMILE doc</a></p></div></div><div class="src-link"><a href="https://github.com/generateme/fastmath/blob/master/src/fastmath/clustering.clj#L167">view source</a></div></div><div class="public anchor" id="var-mec"><h3>mec</h3><div class="usage"><code>(mec data max-clusters radius)</code><code>(mec data dist max-clusters radius)</code></div><div class="doc"><div class="markdown"><p>Nonparametric Minimum Conditional Entropy Clustering algorithm.</p>
<p>Input:</p>
<ul>
  <li>data - sequence of samples</li>
  <li>dist (optional) - distance method, default <code>:euclidean</code></li>
  <li>max-clusters - maximum number of clusters</li>
  <li>radius - the neighborhood radius</li>
</ul>
<p>See more in <a href="https://haifengl.github.io/api/java/smile/clustering/MEC.html">SMILE doc</a></p></div></div><div class="markdown"><h4>Examples</h4><div><blockquote><p>2d vectors</p></blockquote><pre><code class="hljs clojure">(dissoc (mec (repeatedly
              5000
              (fn* []
                (vector
                 (r/randval 0.1 (r/irand -10 10) (r/irand 100 150))
                 (r/randval (r/irand -10 10) (r/irand 100 150)))))
             d/manhattan
             8
             20)
        :data :clustering
        :obj :predict)
;;=&gt; {:clusters 4,
;;=&gt;  :info {:entropy 0.0},
;;=&gt;  :representatives nil,
;;=&gt;  :sizes (2188 261 2294 257 0),
;;=&gt;  :type :mec}</code></pre></div></div><div class="src-link"><a href="https://github.com/generateme/fastmath/blob/master/src/fastmath/clustering.clj#L279">view source</a></div></div><div class="public anchor" id="var-outlier-id"><h3>outlier-id</h3><h4 class="dynamic">const</h4><div class="usage"></div><div><div class="markdown"><code class="hljs clojure">;;=&gt; 2147483647</code></div></div><div class="doc"><div class="markdown"><p>Id of the cluster which contain outliers.</p></div></div><div class="src-link"><a href="https://github.com/generateme/fastmath/blob/master/src/fastmath/clustering.clj#L68">view source</a></div></div><div class="public anchor" id="var-predict"><h3>predict</h3><div class="usage"><code>(predict cluster in)</code></div><div class="doc"><div class="markdown"><p>Predict cluster for given vector</p></div></div><div class="src-link"><a href="https://github.com/generateme/fastmath/blob/master/src/fastmath/clustering.clj#L74">view source</a></div></div><div class="public anchor" id="var-regroup"><h3>regroup</h3><div class="usage"><code>(regroup {:keys [clustering data representatives sizes]})</code></div><div class="doc"><div class="markdown"><p>Transform clustering result into list of clusters as separate maps.</p>
<p>Every map contain:</p>
<ul>
  <li><code>:key</code> - cluster id or <code>:outliers</code></li>
  <li><code>:data</code> - samples which belong to the cluster</li>
  <li><code>:representative</code> - centroid/medoid or average vector if the former is not available</li>
  <li><code>:size</code> - size of cluster</li>
</ul>
<p>Representative is always a n-dimensional sequence even if input is a list of numbers.</p>
<p>Empty clusters are skipped.</p></div></div><div class="markdown"><h4>Examples</h4><div><blockquote><p>Result of clustering with regrouping</p></blockquote><pre><code class="hljs clojure">(k-means [1 2 3 -1 -1 2 -1 11 111] 7)
;;=&gt; #fastmath.clustering.ClusteringResult
;;=&gt;  {:clustering (2 4 5 1 1 4 1 3 0),
;;=&gt;   :clusters 7,
;;=&gt;   :data [1 2 3 -1 -1 2 -1 11 111],
;;=&gt;   :info {:distortion 0.0},
;;=&gt;   :obj
;;=&gt;   #object[smile.clustering.KMeans 0x430ca35f "Cluster distortion: 0.00000\nCluster size of 9 data points:\nCluster    1      1 (11.1%)\nCluster    2      3 (33.3%)\nCluster    3      1 (11.1%)\nCluster    4      1 (11.1%)\nCluster    5      2 (22.2%)\nCluster    6      1 (11.1%)\nCluster    7      0 ( 0.0%)\n"],
;;=&gt;   :predict #<fn@7ac2db4c fastmath.clustering="" _means[fn]="">,
;;=&gt;   :representatives ((111.0) (-1.0) (1.0) (11.0) (2.0) (3.0) (##NaN)),
;;=&gt;   :sizes (1 3 1 1 2 1 0 0),
;;=&gt;   :type :k-means}
(regroup (k-means [1 2 3 -1 -1 2 -1 11 111] 7))
;;=&gt; ({:data (1), :key 4, :representative (1.0), :size 1}
;;=&gt;  {:data (2 2), :key 5, :representative (2.0), :size 2}
;;=&gt;  {:data (3), :key 0, :representative (3.0), :size 1}
;;=&gt;  {:data (-1 -1 -1), :key 2, :representative (-1.0), :size 3}
;;=&gt;  {:data (11), :key 3, :representative (11.0), :size 1}
;;=&gt;  {:data (111), :key 1, :representative (111.0), :size 1})
(count (regroup (k-means [1 2 3 -1 -1 2 -1 11 111] 7)))
;;=&gt; 6</fn@7ac2db4c></code></pre></div></div><div class="src-link"><a href="https://github.com/generateme/fastmath/blob/master/src/fastmath/clustering.clj#L79">view source</a></div></div><div class="public anchor" id="var-spectral"><h3>spectral</h3><div class="usage"><code>(spectral data clusters sigma)</code><code>(spectral data clusters sigma max-iters tolerance)</code><code>(spectral data clusters samples sigma)</code><code>(spectral data clusters samples sigma max-iters tolerance)</code></div><div class="doc"><div class="markdown"><p>Spectral clustering</p>
<p>Input:</p>
<ul>
  <li>data - sequence of samples</li>
  <li>clusters - number of clusters</li>
  <li>samples (optional) - number of random samples for Nystrom approximation</li>
  <li>sigma - width parameter for Gaussian kernel</li>
  <li>max-iter (optional) - maximum number of iterations</li>
  <li>tolerance (optional) - tolerance of k-means convergence test</li>
</ul>
<p>See more in <a href="https://haifengl.github.io/api/java/smile/clustering/SpectralClustering.html">SMILE doc</a></p></div></div><div class="markdown"><h4>Examples</h4><div><blockquote><p>2d vectors</p></blockquote><pre><code class="hljs clojure">(dissoc (spectral
         (repeatedly
          500
          (fn* []
            (vector (r/randval 0.1 (r/irand -10 10) (r/irand 100 150))
                    (r/randval (r/irand -10 10) (r/irand 100 150)))))
         4
         1)
        :data :clustering
        :obj :predict)
;;=&gt; {:clusters 4,
;;=&gt;  :info {:distortion 30.21200828802679},
;;=&gt;  :representatives nil,
;;=&gt;  :sizes (250 232 14 4 0),
;;=&gt;  :type :spectral}</code></pre></div><div><blockquote><p>2d vectors</p></blockquote><pre><code class="hljs clojure">(dissoc (lloyd
         (repeatedly
          500
          (fn* []
            (vector (r/randval 0.1 (r/irand -10 10) (r/irand 100 150))
                    (r/randval (r/irand -10 10) (r/irand 100 150)))))
         4
         1)
        :data :clustering
        :obj :predict)
;;=&gt; {:clusters 4,
;;=&gt;  :info {:distortion 153771.07878295163},
;;=&gt;  :representatives ((123.53191489361703 -0.49361702127659574)
;;=&gt;                    (125.81900452488688 125.58823529411765)
;;=&gt;                    (0.7407407407407407 0.0)
;;=&gt;                    (1.411764705882353 126.47058823529412)),
;;=&gt;  :sizes (235 221 27 17 0),
;;=&gt;  :type :lloyd}</code></pre></div></div><div class="src-link"><a href="https://github.com/generateme/fastmath/blob/master/src/fastmath/clustering.clj#L293">view source</a></div></div><div class="public anchor" id="var-x-means"><h3>x-means</h3><div class="usage"><code>(x-means data clusters)</code><code>(x-means data clusters max-iter)</code><code>(x-means data clusters max-iter tolerance)</code></div><div class="doc"><div class="markdown"><p>X-Means</p>
<p>Input:</p>
<ul>
  <li>data - sequence of samples</li>
  <li>clusters - number of clusters</li>
  <li>max-iter (optional) - maximum number of iterations</li>
  <li>tolerance (optional) - tolerance of convergence test</li>
</ul>
<p>See more in <a href="https://haifengl.github.io/api/java/smile/clustering/XMeans.html">SMILE doc</a></p></div></div><div class="markdown"><h4>Examples</h4><div><blockquote><p>Expect 2 clusters, gaussian distribution.</p></blockquote><pre><code class="hljs clojure">((juxt :clusters :sizes :representatives)
 (x-means (repeatedly 10000
                      (fn* [] (r/randval (r/grand) (r/grand 5 1.0))))
          4))
;;=&gt; [2 (5067 4933 0) ((4.996424534718907) (-0.010796464047086812))]</code></pre></div></div><div class="src-link"><a href="https://github.com/generateme/fastmath/blob/master/src/fastmath/clustering.clj#L197">view source</a></div></div></div></body></html>