<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>fastmath.clustering documentation</title><script type="text/javascript" async="" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML"></script><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="highlight/solarized-light.css" /><script type="text/javascript" src="highlight/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a> with <a href="https://github.com/xsc/codox-theme-rdash">RDash UI</a> theme</h2><h1><a href="index.html"><span class="project-title"><span class="project-name">Fastmath</span> <span class="project-version">2.2.2-SNAPSHOT</span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>fastmath</span></div></div></li><li class="depth-2 branch"><a href="fastmath.calculus.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>calculus</span></div></a></li><li class="depth-2 branch current"><a href="fastmath.clustering.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>clustering</span></div></a></li><li class="depth-2 branch"><a href="fastmath.complex.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>complex</span></div></a></li><li class="depth-2 branch"><a href="fastmath.core.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>core</span></div></a></li><li class="depth-2 branch"><a href="fastmath.curves.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>curves</span></div></a></li><li class="depth-2 branch"><a href="fastmath.distance.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>distance</span></div></a></li><li class="depth-2 branch"><a href="fastmath.easings.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>easings</span></div></a></li><li class="depth-2 branch"><a href="fastmath.efloat.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>efloat</span></div></a></li><li class="depth-2 branch"><a href="fastmath.fields.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>fields</span></div></a></li><li class="depth-2 branch"><a href="fastmath.gp.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>gp</span></div></a></li><li class="depth-2 branch"><a href="fastmath.grid.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>grid</span></div></a></li><li class="depth-2 branch"><a href="fastmath.interpolation.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>interpolation</span></div></a></li><li class="depth-2 branch"><a href="fastmath.kernel.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>kernel</span></div></a></li><li class="depth-2 branch"><a href="fastmath.matrix.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>matrix</span></div></a></li><li class="depth-2"><a href="fastmath.optimization.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>optimization</span></div></a></li><li class="depth-3 branch"><a href="fastmath.optimization.bo.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>bo</span></div></a></li><li class="depth-3"><a href="fastmath.optimization.lbfgsb.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>lbfgsb</span></div></a></li><li class="depth-2"><a href="fastmath.protocols.html"><div class="inner"><span class="tree" style="top: -83px;"><span class="top" style="height: 92px;"></span><span class="bottom"></span></span><span>protocols</span></div></a></li><li class="depth-3"><a href="fastmath.protocols.matrix.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>matrix</span></div></a></li><li class="depth-2 branch"><a href="fastmath.quaternion.html"><div class="inner"><span class="tree" style="top: -52px;"><span class="top" style="height: 61px;"></span><span class="bottom"></span></span><span>quaternion</span></div></a></li><li class="depth-2 branch"><a href="fastmath.random.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>random</span></div></a></li><li class="depth-2 branch"><a href="fastmath.signal.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>signal</span></div></a></li><li class="depth-2 branch"><a href="fastmath.solver.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>solver</span></div></a></li><li class="depth-2"><a href="fastmath.stats.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>stats</span></div></a></li><li class="depth-3"><a href="fastmath.stats.bootstrap.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>bootstrap</span></div></a></li><li class="depth-2 branch"><a href="fastmath.transform.html"><div class="inner"><span class="tree" style="top: -52px;"><span class="top" style="height: 61px;"></span><span class="bottom"></span></span><span>transform</span></div></a></li><li class="depth-2"><a href="fastmath.vector.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>vector</span></div></a></li></ul></div><div class="sidebar secondary"><h3><a href="#top"><span class="inner">Public Vars</span></a></h3><ul><li class="depth-1"><a href="fastmath.clustering.html#var-clarans"><div class="inner"><span>clarans</span></div></a></li><li class="depth-1"><a href="fastmath.clustering.html#var-clustering-methods-list"><div class="inner"><span>clustering-methods-list</span></div></a></li><li class="depth-1"><a href="fastmath.clustering.html#var-dbscan"><div class="inner"><span>dbscan</span></div></a></li><li class="depth-1"><a href="fastmath.clustering.html#var-denclue"><div class="inner"><span>denclue</span></div></a></li><li class="depth-1"><a href="fastmath.clustering.html#var-deterministic-annealing"><div class="inner"><span>deterministic-annealing</span></div></a></li><li class="depth-1"><a href="fastmath.clustering.html#var-g-means"><div class="inner"><span>g-means</span></div></a></li><li class="depth-1"><a href="fastmath.clustering.html#var-k-means"><div class="inner"><span>k-means</span></div></a></li><li class="depth-1"><a href="fastmath.clustering.html#var-lloyd"><div class="inner"><span>lloyd</span></div></a></li><li class="depth-1"><a href="fastmath.clustering.html#var-mec"><div class="inner"><span>mec</span></div></a></li><li class="depth-1"><a href="fastmath.clustering.html#var-outlier-id"><div class="inner"><span>outlier-id</span></div></a></li><li class="depth-1"><a href="fastmath.clustering.html#var-predict"><div class="inner"><span>predict</span></div></a></li><li class="depth-1"><a href="fastmath.clustering.html#var-regroup"><div class="inner"><span>regroup</span></div></a></li><li class="depth-1"><a href="fastmath.clustering.html#var-spectral"><div class="inner"><span>spectral</span></div></a></li><li class="depth-1"><a href="fastmath.clustering.html#var-x-means"><div class="inner"><span>x-means</span></div></a></li></ul></div><div class="namespace-docs" id="content"><h1 class="anchor" id="top">fastmath.clustering</h1><div class="doc"><div class="markdown"><p>Clustering.</p>
<p>Various clustering algrorithms backed by SMILE library.</p>
<p>Only partition clustering is implemented.</p>
<h3><a href="#input-data" id="input-data"></a>Input data</h3>
<p>Itâ€™s always sequence of n-sized samples as sequences.</p>
<p>For example, 2d samples <code>[[1 2] [2 2] [3 3] ...]</code></p>
<p>For 1d data you can pass sequence of numbers of sequence of 1d seqs of numbers</p>
<pre><code class="language-clojure">[1 2 3]
;; or
[[1] [2] [3]]
</code></pre>
<h3><a href="#distances" id="distances"></a>Distances</h3>
<p>Some of the methods use distance functions, use <a href="fastmath.distance.html">fastmath.distance</a> namespace to create one.</p>
<h3><a href="#output" id="output"></a>Output</h3>
<p>Every function returns record which contains:</p>
<ul>
<li><code>:type</code> - name of the method used</li>
<li><code>:data</code> - input data</li>
<li><code>:clustering</code> - sequence of cluster ids</li>
<li><code>:sizes</code> - sizes of clusters</li>
<li><code>:clusters</code> - number of clusters</li>
<li><code>:predict</code> - predicting function (see below), qualify additional sample</li>
<li><code>:representatives</code> - list of centroids or averages</li>
<li><code>:info</code> - additional statistics for your samples (like distortion)</li>
<li><code>:obj</code> - SMILE object</li>
</ul>
<p>Cluster id is a integer ranging from 0 to the number of clusters minus 1. Some methods mark outliers with <a href="fastmath.clustering.html#var-outlier-id">outlier-id</a>.</p>
<p>Record acts as function and can qualify additonal sample by calling <code>:predict</code> function (or just call <a href="fastmath.clustering.html#var-predict">predict</a>), for example (<code>data</code> is sequence of 3d samples):</p>
<pre><code class="language-clojure">(let [cl (k-means data 10)] (cl [0 1 2]))
</code></pre>
<p>See <a href="fastmath.clustering.html#var-k-means">k-means</a></p>
<h4><a href="#regrouping" id="regrouping"></a>Regrouping</h4>
<p>Clustering record can be regroupped to the list of individual clusters. Call <a href="fastmath.clustering.html#var-regroup">regroup</a> and get list of maps with following structure:</p>
<ul>
<li><code>:key</code> - cluster id or <code>:outliers</code></li>
<li><code>:data</code> - samples which belong to the cluster</li>
<li><code>:representative</code> - centroid or average vector if the former is not available</li>
<li><code>:size</code> - size of cluster</li>
</ul>
</div><div class="markdown"><h4>Categories</h4><ul></ul><p>Other vars: <a>-&gt;ClusteringResult</a> <a href="fastmath.clustering.html#var-clarans">clarans</a> <a href="fastmath.clustering.html#var-clustering-methods-list">clustering-methods-list</a> <a href="fastmath.clustering.html#var-dbscan">dbscan</a> <a href="fastmath.clustering.html#var-denclue">denclue</a> <a href="fastmath.clustering.html#var-deterministic-annealing">deterministic-annealing</a> <a href="fastmath.clustering.html#var-g-means">g-means</a> <a href="fastmath.clustering.html#var-k-means">k-means</a> <a href="fastmath.clustering.html#var-lloyd">lloyd</a> <a>map-&gt;ClusteringResult</a> <a href="fastmath.clustering.html#var-mec">mec</a> <a href="fastmath.clustering.html#var-predict">predict</a> <a href="fastmath.clustering.html#var-regroup">regroup</a> <a href="fastmath.clustering.html#var-spectral">spectral</a> <a href="fastmath.clustering.html#var-x-means">x-means</a></p></div><div class="markdown"><h4>Constants</h4><ul><li><a href="fastmath.clustering.html#var-outlier-id">outlier-id</a> = <code>2147483647</code></li></ul></div></div><div class="public anchor" id="var-clarans"><h3>clarans</h3><div class="usage"><code>(clarans data clusters)</code><code>(clarans data dist clusters)</code><code>(clarans data dist clusters max-neighbor)</code></div><div class="doc"><div class="markdown"><p>Clustering Large Applications based upon RANdomized Search algorithm.</p>
<p>Input:</p>
<ul>
<li>data - sequence of samples</li>
<li>dist (optional) - distance method, default <code>euclidean</code></li>
<li>clusters - number of clusters</li>
<li>max-neighbor (optional) - maximum number of neighbors checked during random search</li>
</ul>
<p>See more in <a href="https://haifengl.github.io/api/java/smile/clustering/CLARANS.html">SMILE doc</a></p>
</div></div><div class="markdown"><h4>Examples</h4><div><blockquote><p>Usage</p>
</blockquote><pre><code class="hljs clojure">(dissoc (clarans (repeatedly
                  1000
                  (fn* []
                    (r/randval 0.1 (r/irand -10 10) (r/irand 100 150))))
                 d/chebyshev
                 2)
        :data :clustering
        :obj :predict)
;;=&gt; {:clusters 2,
;;=&gt;  :info {:distortion 11643.0},
;;=&gt;  :representatives ((126.0) (-1.0)),
;;=&gt;  :sizes (887 113 0),
;;=&gt;  :type :clarans}</code></pre></div></div><div class="src-link"><a href="https://github.com/generateme/fastmath/blob/master/src/fastmath/clustering.clj#L230">view source</a></div></div><div class="public anchor" id="var-clustering-methods-list"><h3>clustering-methods-list</h3><div class="usage"></div><div class="doc"><div class="markdown"><p>List of clustering methods.</p>
</div></div><div class="markdown"><h4>Examples</h4><div><blockquote><p>List of methods</p>
</blockquote><pre><code class="hljs clojure">clustering-methods-list
;;=&gt; (:spectral :dbscan
;;=&gt;            :k-means :mec
;;=&gt;            :clarans :g-means
;;=&gt;            :lloyd :x-means
;;=&gt;            :deterministic-annealing :denclue)</code></pre></div></div><div class="src-link"><a href="https://github.com/generateme/fastmath/blob/master/src/fastmath/clustering.clj#L135">view source</a></div></div><div class="public anchor" id="var-dbscan"><h3>dbscan</h3><div class="usage"><code>(dbscan data min-pts radius)</code><code>(dbscan data dist min-pts radius)</code></div><div class="doc"><div class="markdown"><p>Density-Based Spatial Clustering of Applications with Noise algorithm.</p>
<p>Input:</p>
<ul>
<li>data - sequence of samples</li>
<li>dist (optional) - distance method, default <code>euclidean</code></li>
<li>min-pts - minimum number of neighbors</li>
<li>radius - the neighborhood radius</li>
</ul>
<p>See more in <a href="https://haifengl.github.io/api/java/smile/clustering/DBSCAN.html">SMILE doc</a></p>
</div></div><div class="markdown"><h4>Examples</h4><div><blockquote><p>3d vectors</p>
</blockquote><pre><code class="hljs clojure">(dissoc (dbscan
         (repeatedly
          5000
          (fn* []
            (vector (r/randval 0.1 (r/irand -10 10) (r/irand 100 150))
                    (r/randval (r/irand -10 10) (r/irand 100 150))
                    (r/randval (r/irand -10 10) (r/irand 100 150)))))
         10
         20)
        :data :clustering
        :obj :predict)
;;=&gt; {:clusters 8,
;;=&gt;  :info {},
;;=&gt;  :representatives nil,
;;=&gt;  :sizes (1120 1095 1143 110 1154 133 133 112 0),
;;=&gt;  :type :dbscan}</code></pre></div></div><div class="src-link"><a href="https://github.com/generateme/fastmath/blob/master/src/fastmath/clustering.clj#L261">view source</a></div></div><div class="public anchor" id="var-denclue"><h3>denclue</h3><div class="usage"><code>(denclue data sigma m)</code><code>(denclue data sigma m tolerance)</code><code>(denclue data sigma m tolerance min-pts)</code></div><div class="doc"><div class="markdown"><p>DENsity CLUstering algorithm.</p>
<p>Input:</p>
<ul>
<li>data - sequence of samples</li>
<li>sigma - gaussian kernel parameter</li>
<li>m - number of selected samples, much smaller than number of all samples</li>
<li>tolerance (optional) - tolerance of hill-climbing procedure</li>
<li>min-pts (optional) - minimum number of neighbors for a core attractor</li>
</ul>
<p>See more in <a href="https://haifengl.github.io/api/java/smile/clustering/DENCLUE.html">SMILE doc</a></p>
</div></div><div class="markdown"><h4>Examples</h4><div><blockquote><p>Expect 2 clusters, uniform distribution.</p>
</blockquote><pre><code class="hljs clojure">((juxt :clusters :sizes :representatives)
 (denclue (repeatedly 100 (fn* [] (r/randval (r/drand) (r/drand 5 6))))
          1
          10))
;;=&gt; [2 (45 55 0) nil]
(map
 (fn [m] (dissoc m :data))
 (regroup
  (denclue (repeatedly 1000
                       (fn* [] (r/randval 0.1 (r/drand) (r/drand 5 6))))
           1
           10)))
;;=&gt; ({:key 0, :representative 5.490604385975632, :size 896}
;;=&gt;  {:key 1, :representative 0.4959587011302353, :size 104})</code></pre></div></div><div class="src-link"><a href="https://github.com/generateme/fastmath/blob/master/src/fastmath/clustering.clj#L245">view source</a></div></div><div class="public anchor" id="var-deterministic-annealing"><h3>deterministic-annealing</h3><div class="usage"><code>(deterministic-annealing data max-clusters)</code><code>(deterministic-annealing data max-clusters alpha)</code><code>(deterministic-annealing data max-clusters alpha max-iter)</code><code>(deterministic-annealing data max-clusters alpha max-iter tolerance)</code><code>(deterministic-annealing data max-clusters alpha max-iter tolerance split-tolerance)</code></div><div class="doc"><div class="markdown"><p>Deterministic Annealing algorithm.</p>
<p>Input:</p>
<ul>
<li>data - sequence of samples</li>
<li>max-clusters - number of clusters</li>
<li>alpha (optional) - temperature decreasing factor (valued from 0 to 1)</li>
<li>max-iter (optional) - maximum number of iterations</li>
<li>tolerance (optional) - tolerance of convergence test</li>
<li>split-tolerance (optional) - tolerance to split a cluster</li>
</ul>
<p>See more in <a href="https://haifengl.github.io/api/java/smile/clustering/DeterministicAnnealing.html">SMILE doc</a></p>
</div></div><div class="markdown"><h4>Examples</h4><div><blockquote><p>Usage</p>
</blockquote><pre><code class="hljs clojure">(map (fn [m] (dissoc m :data))
     (-&gt; (repeatedly 1000
                     (fn* []
                       (vector (r/randval (r/grand) (r/grand 5 1.0))
                               (r/randval (r/grand) (r/grand 5 1.0)))))
         (deterministic-annealing 4 0.5)
         (regroup)))
;;=&gt; ({:key 3,
;;=&gt;   :representative (5.0572450906513 5.077243369307559),
;;=&gt;   :size 249}
;;=&gt;  {:key 0,
;;=&gt;   :representative (-0.02174154917700439 0.039179418494971044),
;;=&gt;   :size 267}
;;=&gt;  {:key 1,
;;=&gt;   :representative (5.1259692402989465 -0.02126182547888575),
;;=&gt;   :size 256}
;;=&gt;  {:key 2,
;;=&gt;   :representative (-0.08835290254006334 5.0437728505131325),
;;=&gt;   :size 228})</code></pre></div></div><div class="src-link"><a href="https://github.com/generateme/fastmath/blob/master/src/fastmath/clustering.clj#L208">view source</a></div></div><div class="public anchor" id="var-g-means"><h3>g-means</h3><div class="usage"><code>(g-means data clusters)</code><code>(g-means data clusters max-iter)</code><code>(g-means data clusters max-iter tolerance)</code></div><div class="doc"><div class="markdown"><p>G-Means</p>
<p>Input:</p>
<ul>
<li>data - sequence of samples</li>
<li>clusters - number of clusters</li>
<li>max-iter (optional) - maximum number of iterations</li>
<li>tolerance (optional) - tolerance of convergence test</li>
</ul>
<p>See more in <a href="https://haifengl.github.io/api/java/smile/clustering/GMeans.html">SMILE doc</a></p>
</div></div><div class="markdown"><h4>Examples</h4><div><blockquote><p>Expect 2 clusters, uniform distribution.</p>
</blockquote><pre><code class="hljs clojure">((juxt :clusters :sizes :representatives)
 (g-means (repeatedly 100 (fn* [] (r/randval (r/drand) (r/drand 5 6))))
          4))
;;=&gt; [2 (56 44 0) ((5.534915921265396) (0.4603637393049463))]</code></pre></div></div><div class="src-link"><a href="https://github.com/generateme/fastmath/blob/master/src/fastmath/clustering.clj#L178">view source</a></div></div><div class="public anchor" id="var-k-means"><h3>k-means</h3><div class="usage"><code>(k-means data clusters)</code><code>(k-means data clusters max-iter)</code><code>(k-means data clusters max-iter tolerance)</code></div><div class="doc"><div class="markdown"><p>K-Means++ algorithm.</p>
<p>Input:</p>
<ul>
<li>data - sequence of samples</li>
<li>clusters - number of clusters</li>
<li>max-iter (optional) - maximum number of iterations</li>
<li>tolerance (optional) - tolerance of convergence test</li>
</ul>
<p>See more in <a href="https://haifengl.github.io/api/java/smile/clustering/KMeans.html">SMILE doc</a></p>
</div></div><div class="markdown"><h4>Examples</h4><div><blockquote><p>Usage</p>
</blockquote><pre><code class="hljs clojure">(k-means [1 2 3 -1 -1 2 -1 11 111] 4)
;;=&gt; #fastmath.clustering.ClusteringResult
;;=&gt;  {:clustering (3 3 3 0 0 3 0 2 1),
;;=&gt;   :clusters 4,
;;=&gt;   :data [1 2 3 -1 -1 2 -1 11 111],
;;=&gt;   :info {:distortion 2.0000000000000004},
;;=&gt;   :obj
;;=&gt;   #object[smile.clustering.KMeans 0x7ff42817 "Cluster distortion: 2.00000\nCluster size of 9 data points:\nCluster    1      3 (33.3%)\nCluster    2      1 (11.1%)\nCluster    3      1 (11.1%)\nCluster    4      4 (44.4%)\n"],
;;=&gt;   :predict #<fn@2a910d31 fastmath.clustering="" _means[fn]="">,
;;=&gt;   :representatives ((-1.0) (111.0) (11.0) (2.0)),
;;=&gt;   :sizes (3 1 1 4 0),
;;=&gt;   :type :k-means}</fn@2a910d31></code></pre></div><div><blockquote><p>Clusters group into separate maps.</p>
</blockquote><pre><code class="hljs clojure">(regroup (k-means [1 2 3 -1 -1 2 -1 11 111] 4))
;;=&gt; ({:data (1 2 3 2), :key 3, :representative (2.0), :size 4}
;;=&gt;  {:data (-1 -1 -1), :key 0, :representative (-1.0), :size 3}
;;=&gt;  {:data (11), :key 2, :representative (11.0), :size 1}
;;=&gt;  {:data (111), :key 1, :representative (111.0), :size 1})</code></pre></div><div><blockquote><p>Use as predictor</p>
</blockquote><pre><code class="hljs clojure">(let [cl (k-means [1 2 3 -1 -1 2 -1 11 111] 4)]
  [(cl -1) (cl 10) (cl 100) (cl 1) (cl -1000) (cl 1000)])
;;=&gt; [3 2 1 0 3 1]</code></pre></div></div><div class="src-link"><a href="https://github.com/generateme/fastmath/blob/master/src/fastmath/clustering.clj#L148">view source</a></div></div><div class="public anchor" id="var-lloyd"><h3>lloyd</h3><div class="usage"><code>(lloyd data clusters)</code><code>(lloyd data clusters max-iter)</code><code>(lloyd data clusters max-iter tolerance)</code></div><div class="doc"><div class="markdown"><p>K-Means algorithm, lloyd.</p>
<p>Input:</p>
<ul>
<li>data - sequence of samples</li>
<li>clusters - number of clusters</li>
<li>max-iter (optional) - maximum number of iterations</li>
<li>tolerance (optional) - tolerance of convergence test</li>
</ul>
<p>See more in <a href="https://haifengl.github.io/api/java/smile/clustering/KMeans.html">SMILE doc</a></p>
</div></div><div class="src-link"><a href="https://github.com/generateme/fastmath/blob/master/src/fastmath/clustering.clj#L163">view source</a></div></div><div class="public anchor" id="var-mec"><h3>mec</h3><div class="usage"><code>(mec data max-clusters radius)</code><code>(mec data dist max-clusters radius)</code></div><div class="doc"><div class="markdown"><p>Nonparametric Minimum Conditional Entropy Clustering algorithm.</p>
<p>Input:</p>
<ul>
<li>data - sequence of samples</li>
<li>dist (optional) - distance method, default <code>:euclidean</code></li>
<li>max-clusters - maximum number of clusters</li>
<li>radius - the neighborhood radius</li>
</ul>
<p>See more in <a href="https://haifengl.github.io/api/java/smile/clustering/MEC.html">SMILE doc</a></p>
</div></div><div class="markdown"><h4>Examples</h4><div><blockquote><p>2d vectors</p>
</blockquote><pre><code class="hljs clojure">(dissoc (mec (repeatedly
              5000
              (fn* []
                (vector
                 (r/randval 0.1 (r/irand -10 10) (r/irand 100 150))
                 (r/randval (r/irand -10 10) (r/irand 100 150)))))
             d/manhattan
             8
             20)
        :data :clustering
        :obj :predict)
;;=&gt; {:clusters 4,
;;=&gt;  :info {:entropy 0.0},
;;=&gt;  :representatives nil,
;;=&gt;  :sizes (236 2244 258 2262 0),
;;=&gt;  :type :mec}</code></pre></div></div><div class="src-link"><a href="https://github.com/generateme/fastmath/blob/master/src/fastmath/clustering.clj#L275">view source</a></div></div><div class="public anchor" id="var-outlier-id"><h3>outlier-id</h3><h4 class="dynamic">const</h4><div class="usage"></div><div><div class="markdown"><code class="hljs clojure">;;=&gt; 2147483647</code></div></div><div class="doc"><div class="markdown"><p>Id of the cluster which contain outliers.</p>
</div></div><div class="src-link"><a href="https://github.com/generateme/fastmath/blob/master/src/fastmath/clustering.clj#L65">view source</a></div></div><div class="public anchor" id="var-predict"><h3>predict</h3><div class="usage"><code>(predict cluster in)</code></div><div class="doc"><div class="markdown"><p>Predict cluster for given vector</p>
</div></div><div class="src-link"><a href="https://github.com/generateme/fastmath/blob/master/src/fastmath/clustering.clj#L71">view source</a></div></div><div class="public anchor" id="var-regroup"><h3>regroup</h3><div class="usage"><code>(regroup {:keys [clustering data representatives sizes]})</code></div><div class="doc"><div class="markdown"><p>Transform clustering result into list of clusters as separate maps.</p>
<p>Every map contain:</p>
<ul>
<li><code>:key</code> - cluster id or <code>:outliers</code></li>
<li><code>:data</code> - samples which belong to the cluster</li>
<li><code>:representative</code> - centroid/medoid or average vector if the former is not available</li>
<li><code>:size</code> - size of cluster</li>
</ul>
<p>Representative is always a n-dimensional sequence even if input is a list of numbers.</p>
<p>Empty clusters are skipped.</p>
</div></div><div class="markdown"><h4>Examples</h4><div><blockquote><p>Result of clustering with regrouping</p>
</blockquote><pre><code class="hljs clojure">(k-means [1 2 3 -1 -1 2 -1 11 111] 7)
;;=&gt; #fastmath.clustering.ClusteringResult
;;=&gt;  {:clustering (4 3 5 0 0 3 0 2 1),
;;=&gt;   :clusters 7,
;;=&gt;   :data [1 2 3 -1 -1 2 -1 11 111],
;;=&gt;   :info {:distortion 0.0},
;;=&gt;   :obj
;;=&gt;   #object[smile.clustering.KMeans 0x2858e600 "Cluster distortion: 0.00000\nCluster size of 9 data points:\nCluster    1      3 (33.3%)\nCluster    2      1 (11.1%)\nCluster    3      1 (11.1%)\nCluster    4      2 (22.2%)\nCluster    5      1 (11.1%)\nCluster    6      1 (11.1%)\nCluster    7      0 ( 0.0%)\n"],
;;=&gt;   :predict #<fn@1ec83e36 fastmath.clustering="" _means[fn]="">,
;;=&gt;   :representatives ((-1.0) (111.0) (11.0) (2.0) (1.0) (3.0) (##NaN)),
;;=&gt;   :sizes (3 1 1 2 1 1 0 0),
;;=&gt;   :type :k-means}
(regroup (k-means [1 2 3 -1 -1 2 -1 11 111] 7))
;;=&gt; ({:data (1), :key 5, :representative (1.0), :size 1}
;;=&gt;  {:data (2 2), :key 3, :representative (2.0), :size 2}
;;=&gt;  {:data (3), :key 4, :representative (3.0), :size 1}
;;=&gt;  {:data (-1 -1 -1), :key 0, :representative (-1.0), :size 3}
;;=&gt;  {:data (11), :key 2, :representative (11.0), :size 1}
;;=&gt;  {:data (111), :key 1, :representative (111.0), :size 1})
(count (regroup (k-means [1 2 3 -1 -1 2 -1 11 111] 7)))
;;=&gt; 6</fn@1ec83e36></code></pre></div></div><div class="src-link"><a href="https://github.com/generateme/fastmath/blob/master/src/fastmath/clustering.clj#L76">view source</a></div></div><div class="public anchor" id="var-spectral"><h3>spectral</h3><div class="usage"><code>(spectral data clusters sigma)</code><code>(spectral data clusters sigma max-iters tolerance)</code><code>(spectral data clusters samples sigma)</code><code>(spectral data clusters samples sigma max-iters tolerance)</code></div><div class="doc"><div class="markdown"><p>Spectral clustering</p>
<p>Input:</p>
<ul>
<li>data - sequence of samples</li>
<li>clusters - number of clusters</li>
<li>samples (optional) - number of random samples for Nystrom approximation</li>
<li>sigma - width parameter for Gaussian kernel</li>
<li>max-iter (optional) - maximum number of iterations</li>
<li>tolerance (optional) - tolerance of k-means convergence test</li>
</ul>
<p>See more in <a href="https://haifengl.github.io/api/java/smile/clustering/SpectralClustering.html">SMILE doc</a></p>
</div></div><div class="markdown"><h4>Examples</h4><div><blockquote><p>2d vectors</p>
</blockquote><pre><code class="hljs clojure">(dissoc (spectral
         (repeatedly
          500
          (fn* []
            (vector (r/randval 0.1 (r/irand -10 10) (r/irand 100 150))
                    (r/randval (r/irand -10 10) (r/irand 100 150)))))
         4
         1)
        :data :clustering
        :obj :predict)
;;=&gt; {:clusters 4,
;;=&gt;  :info {:distortion 23.48482472977856},
;;=&gt;  :representatives nil,
;;=&gt;  :sizes (230 214 36 20 0),
;;=&gt;  :type :spectral}</code></pre></div><div><blockquote><p>2d vectors</p>
</blockquote><pre><code class="hljs clojure">(dissoc (lloyd
         (repeatedly
          500
          (fn* []
            (vector (r/randval 0.1 (r/irand -10 10) (r/irand 100 150))
                    (r/randval (r/irand -10 10) (r/irand 100 150)))))
         4
         1)
        :data :clustering
        :obj :predict)
;;=&gt; {:clusters 4,
;;=&gt;  :info {:distortion 159692.96594819298},
;;=&gt;  :representatives ((124.77184466019418 -0.9174757281553398)
;;=&gt;                    (124.2887029288703 123.59832635983264)
;;=&gt;                    (-0.12 0.0)
;;=&gt;                    (0.03333333333333333 124.36666666666666)),
;;=&gt;  :sizes (206 239 25 30 0),
;;=&gt;  :type :lloyd}</code></pre></div></div><div class="src-link"><a href="https://github.com/generateme/fastmath/blob/master/src/fastmath/clustering.clj#L289">view source</a></div></div><div class="public anchor" id="var-x-means"><h3>x-means</h3><div class="usage"><code>(x-means data clusters)</code><code>(x-means data clusters max-iter)</code><code>(x-means data clusters max-iter tolerance)</code></div><div class="doc"><div class="markdown"><p>X-Means</p>
<p>Input:</p>
<ul>
<li>data - sequence of samples</li>
<li>clusters - number of clusters</li>
<li>max-iter (optional) - maximum number of iterations</li>
<li>tolerance (optional) - tolerance of convergence test</li>
</ul>
<p>See more in <a href="https://haifengl.github.io/api/java/smile/clustering/XMeans.html">SMILE doc</a></p>
</div></div><div class="markdown"><h4>Examples</h4><div><blockquote><p>Expect 2 clusters, gaussian distribution.</p>
</blockquote><pre><code class="hljs clojure">((juxt :clusters :sizes :representatives)
 (x-means (repeatedly 10000
                      (fn* [] (r/randval (r/grand) (r/grand 5 1.0))))
          4))
;;=&gt; [2 (5052 4948 0) ((-0.006061515621489498) (4.98150899565002))]</code></pre></div></div><div class="src-link"><a href="https://github.com/generateme/fastmath/blob/master/src/fastmath/clustering.clj#L193">view source</a></div></div></div></body></html>